# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .json_schema_type import JsonSchemaType


class JsonSchema(UncheckedBaseModel):
    type: JsonSchemaType = pydantic.Field()
    """
    This is the type of output you'd like.
    
    `string`, `number`, `integer`, `boolean` are the primitive types and should be obvious.
    
    `array` and `object` are more interesting and quite powerful. They allow you to define nested structures.
    
    For `array`, you can define the schema of the items in the array using the `items` property.
    
    For `object`, you can define the properties of the object using the `properties` property.
    """

    items: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = pydantic.Field(default=None)
    """
    This is required if the type is "array". This is the schema of the items in the array.
    
    This is of type JsonSchema. However, Swagger doesn't support circular references.
    """

    properties: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = pydantic.Field(default=None)
    """
    This is required if the type is "object". This specifies the properties of the object.
    
    This is a map of string to JsonSchema. However, Swagger doesn't support circular references.
    """

    description: typing.Optional[str] = pydantic.Field(default=None)
    """
    This is the description to help the model understand what it needs to output.
    """

    required: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    This is a list of properties that are required.
    
    This only makes sense if the type is "object".
    """

    regex: typing.Optional[str] = pydantic.Field(default=None)
    """
    This is a regex that will be used to validate data in question.
    """

    value: typing.Optional[str] = pydantic.Field(default=None)
    """
    This the value that will be used in filling the property.
    """

    target: typing.Optional[str] = pydantic.Field(default=None)
    """
    This the target variable that will be filled with the value of this property.
    """

    enum: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    This array specifies the allowed values that can be used to restrict the output of the model.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
